# redditbot.py

import httpstuff
import redditthings
import customexceptions
import json

COOKIEFILE = 'cookies.lwp'

# reddit api
LOGINCALL = 'http://www.reddit.com/api/login'
REPLYCALL = 'http://www.reddit.com/api/comment'


class RedditUser(object):
    def __init__(self, username, secret, useragent):
        self.username = username
        self.secret = secret
        self.useragent = useragent
        self.loggedin = False
        self.login()
        return

    def login(self):
        data = {}
        data['user'] = self.username
        data['passwd'] = self.secret
        data['api_type'] = 'json'

        # TODO: useragent
        response = httpstuff.http.postrequest('%s/%s' % (LOGINCALL, \
                                                         self.username), \
                                              data)
        js = json.loads(response.read())

        # get modhash if login successful
        # (modhash needed when posting)
        try:
            self.modhash = js['json']['data']['modhash']
        except KeyError:
            raise customexceptions.FailedFetch(self.username,
                                         self.secret,
                                         js)
            return
        self.loggedin = True
        httpstuff.http.cj.save(COOKIEFILE)
    
    def reply(self, text, parent_type, parent_id):
        # TODO: See if the cookie has expired
        if not self.loggedin or self.modhash is None:
            context = 'posting \'%s\' as %s in reply to %s with id %s' % \
                      (text, self.username, parent_type, parent_id)
            raise customexceptions.LoginRequired(context)
            return

        data = {}
        data['uh'] = self.modhash
        data['text'] = text
        if parent_type == 'comment':
            data['thing_id'] = 't1_%s' % parent.id
        elif parent_type == 'thread':
            data['thing_id'] = 't3_%s' % parent.id
        else:
            raise customexceptions.WrongInput('replying to a thing', \
                                        'type of parent: %s' % parent_type, \
                                        '\'comment\' or \'thread\'')
            return

        response = httpstuff.http.postrequest(REPLYCALL, data)
        # TODO: Check if request was successful
        return response


class RedditBot(RedditUser):
    def __init__(self, \
                 username, \
                 secret, \
                 useragent, \
                 wantcomments=True, \
                 wantposts=False, \
                 subredditlist=['all'], \
                 fetchblocksize=50, \
                 maxcommentdepth=5):
        super(RedditBot, self).__init__(username, secret, useragent)
        self.wantcomments = wantcomments
        self.wantposts = wantposts
        self.redditerator = redditthings.RedditIterator( \
            subreddits=subredditlist, blocksize=fetchblocksize)
        self.maxcommentdepth = maxcommentdepth
        
    def roamposts(self):
        while True:
            try:
                # TODO: Catch FailedFetch
                post = self.redditerator.nextpost()
                if self.wantposts and self.wantpost(post):
                    replytext = self.composereply(post)
                    # TODO: catch
                    self.reply(replytext, 'thread', post.kind, post.id)
                if self.wantcomments:
                    # TODO: Catch FailedFetch
                    comments_js = self.redditerator.fetchcomments(post)
                    self.roamcomments(comments_js, 0)
            except KeyboardInterrupt:
                break
            except customexceptions.FailedFetch as f:
                print f.message
                break
            except customexceptions.LoginRequired as l:
                self.login()
                continue

    def roamcomments(self, comments_js, depth):
        if depth > self.maxcommentdepth: return
        for comment_js in comments_js:
            comment = redditthings.RedditComment(comment_js['data'])
            if wantcomment(comment):
                replytext = self.composereply(comment)
                self.reply(replytext, 'comment', comment.kind, comment.id)
            self.roamcomments(comment.replies, depth+1)

    def wantpost(self, post):
        print 'Not replying to %s' % post.title
        return False

    def wantcomment(self, comment):
        print 'Not replying to %s' % comment.body[:20]
        return False

    def composereply(self, thing):
        return ''
    
